\chapter{Обзор предметной области}
\label{ch:ch1}

\section{Графовые базы данных}
Множество типов данных можно представлять в виде графов.
Например, это могут быть различные отношения между участниками социальной сети, или картографические данные.

Для хранения таких данных были созданы специализированные базы данных, позволяющие оптимально хранить и извлекать информацию. Одно из наиболее популярных решений это Neo4j\footnote{https://neo4j.com/docs/getting-started/get-started-with-neo4j/graph-database (дата обр. 21.05.2024)}.

Рассмотрим структуру базы данных Neo4j.
Модель графа в этой системе основана на свойствах.
Каждая вершина и ребро может иметь неограниченное количество пар <<ключ-значение>>, или же свойств, которые могут как-то характеризовать эту сущность.
Вершина графа может иметь несколько меток, которые характеризуют различные роли этой вершины в домене графа.
Ребро же имеет направление, т.е. граф всегда ориентированный. Также оно имеет одну метку, которая обозначает тип отношения между вершинами.

Наиболее распространенный способ выполнять запросы к графам -- это строковые языки запросов.
Например, для Neo4j строковым языком является Cypher\footnote{https://neo4j.com/docs/cypher-manual/current/introduction (дата обр. 21.05.2024)}.
Пример запроса на этом языке:

\begin{nobreaks}
    \begin{lstlisting}[language=C]
MATCH (actor:Actor)-[:ACTED_IN]->
    (movie:Movie {title: 'The Matrix'})
RETURN actor.name
\end{lstlisting}
\end{nobreaks}

Если использовать такие языки в исходном коде приложения для выполнения запросов к графам, мы можем получить следующие проблемы:
\begin{enumerate}
    \item Отсутствие проверки корректности запроса на этапе компиляции;
    \item Отсутствие поддержки синтаксиса или рефакторинга в IDE;
    \item Сложность в объединении и переиспользовании отдельно составленных подзапросов в один общий запрос;
    \item Возможная несовместимость языков запросов при смене баз данных.
\end{enumerate}

Вместо использования строковых языков запросов можно использовать ORM (Object-Relational Mapping), который решит некоторые из вышеперечисленных проблем. Но его все равно сложно использовать для составления и переиспользования подзапросов к графу.

Один из способов извлечь данные из графа -- это получить все пути, удовлетворяющие определенным ограничениям.
Путей может быть как ноль, так и бесконечно много, например, когда в графе есть цикл, и он удовлетворяет запросу.

Ограничения на пути можно описать с помощью контекстно-свободной (КС) грамматики.
Например, множество проблем статического анализа программ можно свести к поиску путей в графе с контекстно-свободными ограничениями \cite{RepsProgramAnalysis}.
Также КС-ограничения применяются для графов в области биоинформатики \cite{BioinformaticsCF}, для запросов к RDF-графам \cite{RDF_CF} и т.д.


\section{Парсер-комбинаторы}

Парсер-комбинаторы -- это функции высшего порядка, позволяющие описывать грамматику путем их объединения последовательно или параллельно в более сложные парсеры. Например:
\begin{lstlisting}
val a = "A".p
val s1 = a seq "B".p
val s2 = a seq "C".p
val s = s1 or s2
\end{lstlisting}
В примере выше мы создали парсер \verb|s|, который разбирает строку \verb|"AB"| или \verb|"AС"|, создав его из более примитивных комбинаторов, разбирающих конкретные символы.

Парсер-комбинаторы обычно являются функциями, которые принимают на вход некоторое состояние, а на выход выдают множество пар результатов и новых состояний. В частности для строк, входным состоянием может быть строка, а выходным -- неразобранный остаток строки \cite{Hutton_1992}.

Такие парсер-комбинаторы позволяют описывать грамматику прям в языке программирования общего назначения, поддерживающего функции высшего порядка. Это позволяет избежать изучения нового языка запросов, а также упрощает и ускоряет создание компактных парсеров.

Простые парсер-комбинаторы, реализованные через рекурсивный спуск, не смогут поддерживать такое подмножество КС-грамматик как леворекурсивные.
Например, парсер \verb|s|, определенный как
\begin{lstlisting}[numbers=none, frame=none, xleftmargin=0pt]
s = s seq "A".p
\end{lstlisting}
будет рекурсивно вызывать сам себя бесконечно.
Помимо этого, такие парсеры не могут разбирать циклы в графе без дополнительных модификаций. Например, если тот же парсер \verb|s| был бы определен праворекурсивно, но для ребер с меткой \verb|"A"|, а в графе был бы цикл из таких ребер, то парсер разбирал бы граф бесконечно.
Также парсеры, реализованные через рекурсивный спуск, будут иметь экспоненциальную сложность при разборе \cite{Meerkat}.

Рассмотрим, как можно использовать парсер-комбинаторы для запросов к графам.
Для этого мы можем описать базовые парсеры, которые разбирают вершину или ребро.
Такие парсеры могут использовать предикаты, которые позволят, например, фильтровать исходящие ребра.
Мы можем последовательно объединять такие парсеры, чередуя их для вершины и ребра, тем самым формируя ограничение на определенный путь.
Или же можем объединить их параллельно, чтобы получить ограничения на два или более путей.


\section{Существующие решения}

На данный момент существует не так много решений для запросов к графам на основе парсер-комбинаторов.
Рассмотрим две такие библиотеки: Trails и Meerkat.

\subsection{Trails}

В работе \cite{Trails} обсуждается применимость парсер-комбинаторов для извлечения путей в графе. На основе этой работы авторы разработали библиотеку Trails на языке Scala.

Тип парсера в данной работе описан как
\begin{lstlisting}[language=Scala, numbers=none, frame=none]
type Tr[-E,-I,+O,+A] = E => I => Stream[(O,A)] 
\end{lstlisting}
Он принимает некое окружение и состояние, а на выход выдает последовательность пар состояний и значений. Состоянием может быть как вершина, так и ребро графа.

Комбинаторы типизированы так, чтобы корректно комбинировать парсеры. Например, мы не можем последовательно соединить парсер, который выдает состояния на ребре, с парсером, который принимает состояние на вершине. Соответственно, такая корректность будет проверена на этапе компиляции.

Также интересно рассмотреть функцию \verb|map|:
\begin{lstlisting}[language=Scala, numbers=none, frame=none]
def map[E,I,O,A,B](tr: Tr[E,I,O,A])(f: A => B): Tr[E,I,O,B]
\end{lstlisting}
Она принимает парсер \verb|tr| и функцию \verb|f| и возвращает новый парсер, который действует также, как и исходный, но возвращает результаты типа \verb|B|, которые были получены путем замены результатов парсера \verb|tr| с помощью функции \verb|f|. 
Функцию \texttt{map} можно использовать для добавления различных семантических действий к парсеру. 
Например, мы можем посчитать сумму значений, хранящихся на ребрах графа, прямо во время разбора, в итоге получив сумму на полученном пути.
Или можем извлечь путь в графе, сформировав из него какую-нибудь структуру, например, список ребер.

Выполнение парсеров в библиотеке Trails реализовано через рекурсивный спуск, что не позволяет описывать леворекурсивные грамматики.
Также такой подход работает экспоненциально, как было сказано ранее.

Детектирование циклов в этой библиотеке реализованно только для комбинаторов \verb|many| и \verb|many1|, которые зацикливают переданный им парсер. 
Но мы вполне можем написать парсер без использования таких комбинаторов, но который будет разбирать цикл в графе.
Например, используя рекурсивное или взаимно-рекурсивное определение парсера, тогда разбор будет бесконечно выполняться.

\subsection{Meerkat}

Изначально библиотека Meerkat была разработана для разбора текста. Она основана на идеях и алгоритмах из работы~\cite{Meerkat}. 
Авторы статьи добились асимптотики работы $O(n^3)$, а также поддержали леворекурсивные и неоднозначные грамматик.

В дальнейшем, в рамках работы~\cite{MeerkatGraphs}, данная библиотека была расширена поддержкой разбора графов. Благодаря алгоритмам исходной библиотеки, данное расширение также позволяло разбирать циклы в графе.

Проблемой данного расширения является то, что оно основано на алгоритмах, предназначенных для разбора текста.
В изначальной библиотеке состоянием являлась позиция в строке типа \verb|Int|, которая передавалась в парсер вместе со строкой.
В расширении позиция в строке семантически заменилась на номер узла в графе, который уже передается вместе с самим графом.
Такое поведение отличается от той же библиотеки Trails, в которой было два разных состояния: вершина и ребро в графе.
Таким образом, парсер вершины в Meerkat на самом деле не возвращает новое состояние, а оставляет тоже самое, если оно удовлетворяет предикату.
Из-за этого, например, можно написать два парсера вершины последовательно, что не имеет особого смысла:
\begin{lstlisting}[language=Scala, numbers=none, frame=none]
val p = V() ~ V()
\end{lstlisting}

Соответственно, любой парсер будет последовательно комбинироваться с любым другим парсером, т.к. тип выходного состояния первого парсера и тип входного состояния второго всегда одинаковы и равны \verb|Int|.

Другой проблемой данной библиотеки является повсеместное использование функции-макроса \verb|syn| при определении парсера.
К сожалению, ни в статье, ни в исходном коде нет пояснений, для чего вводилась данная функция, но судя по ее определениям, она неявно конвертирует аргумент к типу парсера. Например, если в нее передается строка, то он создает парсер этой строки, а в расширении для графов: парсер ребра с такой меткой.
Но, например, такой простой пример не компилируется:
\begin{lstlisting}[language=Scala, numbers=none, frame=none]
val p = (V() ^ (_ => 1)) ~ (outE() ^ (_ => 2)) &
            { case a ~ b => a + b }
\end{lstlisting}
Здесь мы разбираем вершину и любое исходящее ребро, при этом вершину заменяем на число 1, а ребро на число 2, а результат заменяем на их сумму.
При этом тут не требуется конвертация в парсер, т.к. комбинаторы \verb|V()| и \verb|outE()| уже должны были создать парсеры. Если обернуть \verb|V()| и \verb|outE()| в \verb|syn|, оно компилируется.

Еще одной проблемой является отсутствие проверки типов в некоторых местах на этапе компиляции.
Например, возьмем такой код:

\begin{nobreaks}
\begin{lstlisting}[language=Scala, numbers=none, frame=none]
val p     = syn(V((_: String) == "x"))
val graph = Graph((0 ~+#> 1)("a"), (2 ~+#> 3)("b"))
val input = new MyGraphxInput(graph)
parse(p, input)
\end{lstlisting}
\end{nobreaks}

Здесь мы создаем парсер вершины \verb|p|, предикат которой принимает вершины типа \verb|String|.
Соответственно, такой парсер должен работать только с графами, у которых вершины имеют тип \verb|String|.
Но далее мы создаем граф, у которого вершины имеют тип \verb|Int|, после чего мы разбираем этот граф парсером \verb|p|.
Этот код компилируется, но во время выполнения мы получаем ошибку:
\begin{lstlisting}[language=TeX]
java.lang.ClassCastException: 
    java.lang.Integer cannot be cast to java.lang.String
\end{lstlisting}

С другой стороны, в данной библиотеке используются различные алгоритмы, позволяющие существенно ускорить время выполнения, по сравнению с библиотекой Trails~\cite{MeerkatGraphs}. 

