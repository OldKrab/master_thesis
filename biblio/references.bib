% use BibItNow to create bib entries

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% All other sources
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




@inproceedings{RepsProgramAnalysis,
author = {Reps, Thomas},
title = {Program analysis via graph reachability},
year = {1997},
isbn = {0262631806},
publisher = {MIT Press},
address = {Cambridge, MA, USA},
booktitle = {Proceedings of the 1997 International Symposium on Logic Programming},
pages = {5–19},
numpages = {15},
location = {Port Washington, New York, USA},
series = {ILPS '97}
}

@article{BioinformaticsCF,
author = {Sevon, Petteri and Eronen, Lauri},
year = {2016},
month = {10},
pages = {},
title = {Subgraph Queries by Context-free Grammars},
volume = {5},
journal = {Journal of Integrative Bioinformatics},
doi = {10.1515/jib-2008-100}
}

@InProceedings{RDF_CF,
author="Zhang, Xiaowang
and Feng, Zhiyong
and Wang, Xin
and Rao, Guozheng
and Wu, Wenrui",
editor="Groth, Paul
and Simperl, Elena
and Gray, Alasdair
and Sabou, Marta
and Kr{\"o}tzsch, Markus
and Lecue, Freddy
and Fl{\"o}ck, Fabian
and Gil, Yolanda",
title="Context-Free Path Queries on RDF Graphs",
booktitle="The Semantic Web -- ISWC 2016",
year="2016",
publisher="Springer International Publishing",
address="Cham",
pages="632--648",
abstract="Navigational graph queries are an important class of queries that can extract implicit binary relations over the nodes of input graphs. Most of the navigational query languages used in the RDF community, e.g. property paths in W3C SPARQL 1.1 and nested regular expressions in nSPARQL, are based on the regular expressions. It is known that regular expressions have limited expressivity; for instance, some natural queries, like same generation-queries, are not expressible with regular expressions. To overcome this limitation, in this paper, we present cfSPARQL, an extension of SPARQL query language equipped with context-free grammars. The cfSPARQL language is strictly more expressive than property paths and nested expressions. The additional expressivity can be used for modelling graph similarities, graph summarization and ontology alignment. Despite the increasing expressivity, we show that cfSPARQL still enjoys a low computational complexity and can be evaluated efficiently.",
isbn="978-3-319-46523-4"
}

@article{Hutton_1992, 
title={Higher-order functions for parsing}, 
volume={2}, 
DOI={10.1017/S0956796800000411}, 
number={3}, 
journal={Journal of Functional Programming}, 
author={Hutton, Graham}, 
year={1992}, 
pages={323–343}} 

@inproceedings{Trails,
author = {Kr\"{o}ni, Daniel and Schweizer, Raphael},
title = {Parsing graphs: applying parser combinators to graph traversals},
year = {2013},
isbn = {9781450320641},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2489837.2489844},
doi = {10.1145/2489837.2489844},
abstract = {Connected data such as social networks or business process interactions are frequently modeled as graphs, and increasingly often, stored in graph databases. In contrast to relational databases where SQL is the proven query language, there is no established counterpart for graph databases.One way to explore and extract data from a graph database is to specify the structure of paths (partial traversals) through the graph.We show how such traversals can be expressed by combining graph navigation primitives with familiar grammar constructions such as sequencing, choice and repetition -- essentially applying the idea of parser combinators to graph traversals.The result is trails [6], a Scala combinator library that provides an implementation for the neo4j graph database [7] and for the generic graph API blueprints [8].},
booktitle = {Proceedings of the 4th Workshop on Scala},
articleno = {7},
numpages = {4},
keywords = {parser combinators, graph traversal, graph database, domain specific language, Scala},
location = {Montpellier, France},
series = {SCALA '13}
}

@inproceedings{MeerkatGraphs,
author = {Verbitskaia, Ekaterina and Kirillov, Ilya and Nozkin, Ilya and Grigorev, Semyon},
title = {Parser combinators for context-free path querying},
year = {2018},
isbn = {9781450358361},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3241653.3241655},
doi = {10.1145/3241653.3241655},
abstract = {Transparent integration of a domain-specific language for specification of context-free path queries (CFPQs) into a general-purpose programming language as well as static checking of errors in queries may greatly simplify the development of applications using CFPQs. LINQ and ORM can be used for the integration, but they have issues with flexibility: query decomposition and reusing of subqueries are a challenge. Adaptation of parser combinators technique for paths querying may solve these problems. Conventional parser combinators process linear input, and only the Trails library is known to apply this technique for path querying. Trails suffers the common parser combinators issue: it does not support left-recursive grammars and also experiences problems in cycles handling. We demonstrate that it is possible to create general parser combinators for CFPQ which support arbitrary context-free grammars and arbitrary input graphs. We implement a library of such parser combinators and show that it is applicable for realistic tasks.},
booktitle = {Proceedings of the 9th ACM SIGPLAN International Symposium on Scala},
pages = {13–23},
numpages = {11},
keywords = {Scala, Parser Combinators, Neo4j, Language-Constrained Path Problem, Graph Databases, Generalized LL, GLL, Context-Free Path Querying, Context-Free Language Reachability},
location = {St. Louis, MO, USA},
series = {Scala 2018}
}

@inproceedings{Meerkat,
author = {Izmaylova, Anastasia and Afroozeh, Ali and Storm, Tijs van der},
title = {Practical, general parser combinators},
year = {2016},
isbn = {9781450340977},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2847538.2847539},
doi = {10.1145/2847538.2847539},
abstract = {Parser combinators are a popular approach to parsing where context-free grammars are represented as executable code. However, conventional parser combinators do not support left recursion, and can have worst-case exponential runtime. These limitations hinder the expressivity and performance predictability of parser combinators when constructing parsers for programming languages. In this paper we present general parser combinators that support all context-free grammars and construct a parse forest in cubic time and space in the worst case, while behaving nearly linearly on grammars of real programming languages. Our general parser combinators are based on earlier work on memoized Continuation-Passing Style (CPS) recognizers. First, we extend this work to achieve recognition in cubic time. Second, we extend the resulting cubic CPS recognizers to parsers that construct a binarized Shared Packed Parse Forest (SPPF). Our general parser combinators bring the best of both worlds: the flexibility and extensibility of conventional parser combinators and the expressivity and performance guarantees of general parsing algorithms. We used the approach presented in this paper as the basis for Meerkat, a general parser combinator library for Scala.},
booktitle = {Proceedings of the 2016 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
pages = {1–12},
numpages = {12},
keywords = {memoization, left recursion, higher-order functions, general parsing, continuation-passing style, Parser combinators},
location = {St. Petersburg, FL, USA},
series = {PEPM '16}
}

@article{MemoizationJohnson,
    title = "Squibs and Discussions: Memoization in Top-Down Parsing",
    author = "Johnson, Mark",
    editor = "Hirschberg, Julia",
    journal = "Computational Linguistics",
    volume = "21",
    number = "3",
    year = "1995",
    address = "Cambridge, MA",
    publisher = "MIT Press",
    url = "https://aclanthology.org/J95-3005",
    pages = "405--417",
}

@PHDThesis{RekersSppf,
 title                = {Parser generation for interactive environments},
 author               = {Rekers, Jan},
 year                 = 1992,
 month                = jan
}

@inproceedings{BinSppf,
    title = "The Structure of Shared Forests in Ambiguous Parsing",
    author = "Billot, Sylvie  and
      Lang, Bernard",
    booktitle = "27th Annual Meeting of the Association for Computational Linguistics",
    month = jun,
    year = "1989",
    address = "Vancouver, British Columbia, Canada",
    publisher = "Association for Computational Linguistics",
    url = "https://aclanthology.org/P89-1018",
    doi = "10.3115/981623.981641",
    pages = "143--151",
}
